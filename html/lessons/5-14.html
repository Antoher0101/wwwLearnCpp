<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport"
	      content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<link href="../../css/styles.css" rel="stylesheet" type="text/css">
	<title>Изучение C++</title>
</head>
<body>
<!--HEADER START-->
<div class="header">
	<div class="header-item">
		<a class="header-link" href="../.." target="_self">
			<span class="flex-span" style="display: flex;">
			<svg class="icon" height="48" width="48" viewBox="0 0 32 32">
				<path d="M29,10.232a2.387,2.387,0,0,0-.318-1.244,2.451,2.451,0,0,0-.936-.879Q22.552,5.241,17.353,2.376A2.642,2.642,0,0,0,14.59,2.4c-1.378.779-8.275,4.565-10.331,5.706A2.287,2.287,0,0,0,3,10.231V21.77a2.4,2.4,0,0,0,.3,1.22,2.434,2.434,0,0,0,.954.9c2.056,1.141,8.954,4.927,10.332,5.706a2.642,2.642,0,0,0,2.763.026q5.19-2.871,10.386-5.733a2.444,2.444,0,0,0,.955-.9,2.4,2.4,0,0,0,.3-1.22V10.232"
				      style="fill:#909090"/>
				<path d="M28.549,23.171a2.126,2.126,0,0,0,.147-.182,2.4,2.4,0,0,0,.3-1.22V10.232a2.387,2.387,0,0,0-.318-1.244c-.036-.059-.089-.105-.13-.16L16,16Z"
				      style="fill:#464646"/>
				<path d="M28.549,23.171,16,16,3.451,23.171a2.435,2.435,0,0,0,.809.72c2.056,1.141,8.954,4.927,10.332,5.706a2.642,2.642,0,0,0,2.763.026q5.19-2.871,10.386-5.733A2.43,2.43,0,0,0,28.549,23.171Z"
				      style="fill:#363636"/>
				<path d="M19.6,18.02a4.121,4.121,0,1,1-.027-4.087l3.615-2.073A8.309,8.309,0,0,0,7.7,16a8.216,8.216,0,0,0,1.1,4.117A8.319,8.319,0,0,0,23.211,20.1L19.6,18.02"
				      color=""/>
				<polygon
						points="24.076 15.538 23.15 15.538 23.15 14.617 22.225 14.617 22.225 15.538 21.299 15.538 21.299 16.461 22.225 16.461 22.225 17.381 23.15 17.381 23.15 16.461 24.076 16.461 24.076 15.538"
						style="fill:#fff"/>
				<polygon
						points="27.549 15.538 26.623 15.538 26.623 14.617 25.697 14.617 25.697 15.538 24.771 15.538 24.771 16.461 25.697 16.461 25.697 17.381 26.623 17.381 26.623 16.461 27.549 16.461 27.549 15.538"
						style="fill:#fff"/>
			</svg>
			Leaner
			</span>
		</a>
	</div>
	<div class="v-splitter header-item"></div>
	<nav class="flex-container flex-space-between one-third-width flex-no-wrap">
		<a href="../faq.html" class="header-link header-item">FAQ</a>
		<a href="text-guide-introduction.html" class="header-link header-item">Учебник</a>
		<a href="../video-lessons.html" class="header-link header-item">Видеоуроки</a>
		<a href="../compiler.html" class="header-link header-item">Компилятор</a>
		<a href="https://github.com/Antoher0101/wwwLearnCpp" target="_blank" class="header-link header-item">Github</a>
	</nav>
</div>
<!--HEADER END-->

<main class="wrapper sidebar-position">
	<div id="main-content" class="centered-container">
		<!--		MAIN ARTICLES START-->
		<div class="container-content bordered-container">
			<div class="centered-container">
				<span class="content-header">Перегрузка операторов</span>
				<div class="container-content">
					Перегрузка операторов позволяет определить действия, которые будет выполнять оператор. Перегрузка
					подразумевает создание функции, название которой содержит слово <b>operator</b> и символ перегружаемого
					оператора. Функция оператора может быть определена как член класса, либо вне класса.
					<br><br>
					Перегрузить можно только те операторы, которые уже определены в C++. Создать новые операторы нельзя.
					<br><br>
					Если функция оператора определена как отдельная функция и не является членом класса, то количество
					параметров такой функции совпадает с количеством операндов оператора. Например, у функции, которая
					представляет унарный оператор, будет один параметр, а у функции, которая представляет бинарный
					оператор, - два параметра. Если оператор принимает два операнда, то первый операнд передается
					первому параметру функции, а второй операнд - второму параметру. При этом как минимум один из
					параметров должен представлять тип класса
					<br><br>
					Рассмотрим пример с классом Counter, который представляет секундомер и хранит количество секунд:
					<div class="code-container code">#include &lt;iostream&gt;

class Counter
{
public:
	Counter(int sec)
	{
		seconds = sec;
	}
	void display()
	{
		std::cout << seconds << " seconds" << std::endl;
	}
	int seconds;
};

Counter operator + (Counter c1, Counter c2)
{
	return Counter(c1.seconds + c2.seconds);
}

int main()
{
	Counter c1(20);
	Counter c2(10);
	Counter c3 = c1 + c2;
	c3.display(); // 30 seconds

	return 0;
}</div>
						Здесь функция оператора не является частью класса Counter и определена вне его. Данная функция
						перегружает оператор сложения для типа Counter. Она является бинарной, поэтому принимает два
						параметра. В данном случае мы складываем два объекта Counter. Возвращает функция также объект
						Counter, который хранит общее количесто секунд. То есть по сути здесь операция сложения сводится
						к сложению секунд обоих объектов:
					<div class="code-container code">Counter operator + (Counter c1, Counter c2)
{
	return Counter(c1.seconds + c2.seconds);
}</div>
						При этом необязательно возвращать объект класса. Это может быть и объект встроенного
						примитивного типа. И также мы можем определять дополнительные перегруженные функции операторов:
					<div class="code-container code"> int operator + (Counter c1, int s)
{
	return c1.seconds + s;
}</div>
						Данная версия складывает объект Counter с числом и возвращает также число. Поэтому левый операнд
						операции должен представлять тип Counter, а правый операнд - тип int. И, к примеру, мы можем
						применить данную версию оператора следующим образом:
					<div class="code-container code">Counter c1(20);
int seconds = c1 + 25; // 45
std::cout << seconds << std::endl;</div>
						Также функции операторов могут быть определены как члены классов. Если функция оператора
						определена как член класса, то левый операнд доступен через указатель this и представляет
						текущий объект, а правый операнд передается в подобную функцию в качестве единственного
						параметра:
					<div class="code-container code">#include &lt;iostream&gt;

class Counter
{
public:
	Counter(int sec)
	{
		seconds = sec;
	}
	void display()
	{
		std::cout << seconds << " seconds" << std::endl;
	}
	Counter operator + (Counter c2)
	{
		return Counter(this->seconds + c2.seconds);
	}
	int operator + (int s)
	{
		return this->seconds + s;
	}
	int seconds;
};

int main()
{
	Counter c1(20);
	Counter c2(10);
	Counter c3 = c1 + c2;
	c3.display(); // 30 seconds
	int seconds = c1 + 25; // 45

	return 0;
}</div>
							В данном случае к левому операнду в функциях операторов мы обращаемся через указатель this.
							<br><br>
							Какие операторы где переопределять? Операторы присвоения, индексирования ([]), вызова (()),
							доступа к члену класса по указателю (->) следует определять в виде функций-членов класса.
							Операторы, которые изменяют состояние объекта или непосредственно связаны с объектом
							(инкремент, декремент,), обычно также определяются в виде функций-членов класса. Все
							остальные операторы чаще определяются как отдельные функции, а не члены класса.
				</div>
				<div class="container-content">
					<span class="content-subheader">Операторы сравнения</span>
					Ряд операторов перегружаются парами. Например, если мы определяем оператор <b>==</b>, то необходимо также
					определить и оператор <b>!=</b>. А при определении оператора &lt; надо также определять функцию для оператора
					&gt;. Например, перегрузим данные операторы:
					<div class="code-container code">bool operator == (Counter c1, Counter c2)
{
	return c1.seconds == c2.seconds;
}
bool operator != (Counter c1, Counter c2)
{
	return c1.seconds != c2.seconds;
}
bool operator > (Counter c1, Counter c2)
{
	return c1.seconds > c2.seconds;
}
bool operator < (Counter c1, Counter c2)
{
	return c1.seconds < c2.seconds;
}
int main()
{
	Counter c1(20);
	Counter c2(10);
	bool b1 = c1 == c2;     // false
	bool b2 = c1 > c2;       // true

	std::cout << b1 << std::endl;
	std::cout << b2 << std::endl;

	return 0;
}</div>
				</div>
				<div class="container-content">
					<span class="content-subheader">Операторы присвоения</span>
					Операторы присвоения обычно возвращает ссылку на свой левый операнд:
					<div class="code-container code">#include &lt;iostream&gt;

class Counter
{
public:
	Counter(int sec)
	{
		seconds = sec;
	}
	void display()
	{
		std::cout << seconds << " seconds" << std::endl;
	}
	Counter& operator += (Counter c2)
	{
		seconds += c2.seconds;
		return *this;
	}
	int seconds;
};
int main()
{
	Counter c1(20);
	Counter c2(10);
	c1 += c2;
	c1.display(); // 30 seconds
	return 0;
}</div>
						Операции инкремента и декремента
						<br><br>
						Особую сложность может представлять переопределение операций инкремента и декремента, поскольку
						нам надо определить и префиксную, и постфиксную форму для этих операторов. Определим подобные
						операторы для типа Counter:
					<div class="code-container code">#include &lt;iostream&gt;

class Counter
{
public:
	Counter(int sec)
	{
		seconds = sec;
	}
	void display()
	{
		std::cout << seconds << " seconds" << std::endl;
	}
	// префиксные операторы
	Counter& operator++ ()
	{
		seconds += 5;
		return *this;
	}
	Counter& operator-- ()
	{
		seconds -= 5;
		return *this;
	}
	// постфиксные операторы
	Counter operator++ (int)
	{
		Counter prev = *this;
		++*this;
		return prev;
	}
	Counter operator-- (int)
	{
		Counter prev = *this;
		--*this;
		return prev;
	}
	int seconds;
};
int main()
{
	Counter c1(20);
	Counter c2 = c1++;
	c2.display(); // 20 seconds
	c1.display(); // 25 seconds
	--c1;
	c1.display(); // 20 seconds
	return 0;
}</div>
							Префиксные операторы должны возвращать ссылку на текущий объект, который можно получить с
							помощью указателя this:
					<div class="code-container code">Counter& operator++ ()
{
	seconds += 5;
	return *this;
}</div>
							В самой функции можно определить некоторую логику по инкременту значения. В данном случае
							количество секунд увеличивается на 5.
							<br><br>
							Постфиксные операторы должны возвращать значение объекта до инкремента, то есть предыдущее
							состояние объекта. Чтобы постфиксная форма отличалась от префиксной постфиксные версии
							получают дополнительный параметр типа int, который не используется. Хотя в принципе мы можем
							его использовать.
					<div class="code-container code">Counter operator++ (int)
{
	Counter prev = *this;
	++*this;
	return prev;
}</div>
				</div>
				<div class="code-container">Вся информация принадлежит сайту <a href="https://metanit.com/"
				                                                                target="_blank">METANIT.COM</a></div>
				<div class="centered-content">
					<a href="5-13.html">Назад</a>
					<a href="text-guide-introduction.html">Содержание</a>
					<a href="5-15.html">Вперед</a>
				</div>
			</div>
		</div>
		<!--MAIN ARTICLES END-->
	</div>

</main>
<!--FOOTER START-->
<footer class="footer centered-container border-top">
	<div class="flex-container flex-items-center f12">
		<ul class="list-style-none" style="margin-top: 6px;width: 16%;">
			<li class="flex-items-center">
				<a class="header-link" href="https://github.com/Antoher0101" target="_blank">
					<span>
						<img alt="@Antoher0101" class="avatar circle"
						     height="24" src="https://avatars.githubusercontent.com/u/62786345?s=96&amp;v=4" width="24">
					 © 2022 Antoher0101 </span>
				</a>

			</li>
		</ul>
		<ul class="flex-ul list-style-none two-third-width flex-space-between">
			<li class="flex-items-center"><a href="https://github.com/Antoher0101/wwwLearnCpp" target="_self">This
			                                                                                                  repository</a>
			</li>
			<li class="flex-items-center"><a href="https://github.com/Antoher0101/wwwLearnCpp/commits/master"
			                                 target="_blank">Commits</a></li>
			<li class="flex-items-center"><a href="https://github.com/Antoher0101/wwwLearnCpp/blob/master/README.md"
			                                 target="_blank">About</a></li>
		</ul>
	</div>
</footer>
<!--FOOTER END-->
<script src="../../js/jquery.min.js"></script>
<script src="../../js/ace/ace.js"></script>
<script>
    var code;
    $('.code').each(function () {
        code = ace.edit(this);
        code.setTheme("ace/theme/one_dark");
        code.getSession().setMode("ace/mode/c_cpp");
        code.setShowPrintMargin(false);
        code.setReadOnly(true);
        code.setOptions({
            maxLines: Infinity,
            fontSize: "12pt",
        });
        code.$blockScrolling = Infinity;
    });
</script>
</body>
</html>