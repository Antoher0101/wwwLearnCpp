<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport"
	      content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<link href="../css/styles.css" rel="stylesheet" type="text/css">
	<title>Изучение C++</title>
</head>
<body>
<!--HEADER START-->
<div class="header">
	<div class="header-item">
		<a class="header-link" href="../index.html" target="_self">
			<span class="flex-span" style="display: flex;">
			<svg class="icon" height="48" width="48" viewBox="0 0 32 32">
				<path d="M29,10.232a2.387,2.387,0,0,0-.318-1.244,2.451,2.451,0,0,0-.936-.879Q22.552,5.241,17.353,2.376A2.642,2.642,0,0,0,14.59,2.4c-1.378.779-8.275,4.565-10.331,5.706A2.287,2.287,0,0,0,3,10.231V21.77a2.4,2.4,0,0,0,.3,1.22,2.434,2.434,0,0,0,.954.9c2.056,1.141,8.954,4.927,10.332,5.706a2.642,2.642,0,0,0,2.763.026q5.19-2.871,10.386-5.733a2.444,2.444,0,0,0,.955-.9,2.4,2.4,0,0,0,.3-1.22V10.232"
				      style="fill:#909090"/>
				<path d="M28.549,23.171a2.126,2.126,0,0,0,.147-.182,2.4,2.4,0,0,0,.3-1.22V10.232a2.387,2.387,0,0,0-.318-1.244c-.036-.059-.089-.105-.13-.16L16,16Z"
				      style="fill:#464646"/>
				<path d="M28.549,23.171,16,16,3.451,23.171a2.435,2.435,0,0,0,.809.72c2.056,1.141,8.954,4.927,10.332,5.706a2.642,2.642,0,0,0,2.763.026q5.19-2.871,10.386-5.733A2.43,2.43,0,0,0,28.549,23.171Z"
				      style="fill:#363636"/>
				<path d="M19.6,18.02a4.121,4.121,0,1,1-.027-4.087l3.615-2.073A8.309,8.309,0,0,0,7.7,16a8.216,8.216,0,0,0,1.1,4.117A8.319,8.319,0,0,0,23.211,20.1L19.6,18.02"
				      color=""/>
				<polygon
						points="24.076 15.538 23.15 15.538 23.15 14.617 22.225 14.617 22.225 15.538 21.299 15.538 21.299 16.461 22.225 16.461 22.225 17.381 23.15 17.381 23.15 16.461 24.076 16.461 24.076 15.538"
						style="fill:#fff"/>
				<polygon
						points="27.549 15.538 26.623 15.538 26.623 14.617 25.697 14.617 25.697 15.538 24.771 15.538 24.771 16.461 25.697 16.461 25.697 17.381 26.623 17.381 26.623 16.461 27.549 16.461 27.549 15.538"
						style="fill:#fff"/>
			</svg>
			Leaner
			</span>
		</a>
	</div>
	<div class="v-splitter header-item"></div>
	<nav class="flex-container flex-space-between one-third-width flex-no-wrap">
		<a href="faq.html" class="header-link header-item">FAQ</a>
		<a href="lessons/text-guide-introduction.html" class="header-link header-item">Учебник</a>
		<a href="video-lessons.html" class="header-link header-item">Видеоуроки</a>
		<a href="compiler.html" class="header-link header-item">Компилятор</a>
		<a href="https://github.com/Antoher0101/wwwLearnCpp" target="_blank" class="header-link header-item">Github</a>
	</nav>
</div>
<!--HEADER END-->

<main class="wrapper sidebar-position">
	<div id="main-content" class="Layout centered-container">
		<!--		MAIN ARTICLES START-->
		<div class="Layout-main">
			<div id="Faq-article" class="centered-container bordered-container">
				<div class="container-content">
					<span class="content-header">Краткий FAQ по C++</span>
					Этот документ является переводом сборника ответов на часто задаваемые вопросы группы новостей
					comp.lang.c++. Разделы будут добавляться по мере их перевода. Последнюю английскую версию этого
					сборника можно найти на
					<a href=" http://www.parashift.com/c++-faq-lite" target="_blank">
						http://www.parashift.com/c++-faq-lite</a>.
					<br><br>
					<details>
						<summary>Авторские права</summary>
						<div class="code-container">
							Вы можете свободно использовать этот документ в некоммерческих целях и делать
							копии его или его частей для личного использования, при условии сохранения всей информации
							об
							авторских правах, включая это предупреждение. Не допускается цитирование этого документа без
							ссылки
							на источник. Для коммерческого использования этого документа требуется получить разрешение,
							во-первых, автора английской версии, во-вторых, автора этого перевода. Автором английской
							версии
							является Marshall Cline (cline@parashift.com), автором перевода - Ярослав Миронов
							(slava_mironov@mail.ru, tada@mail.wplus.net).
							<br><br>
							[Все зарегистрированные торговые марки, упоминающиеся в настоящем документе, являются
							собственностью
							своих владельцев.]
						</div>
					</details>
				</div>
			</div>
			<div id="References-article" class="centered-container bordered-container">
				<div class="container-content">
					<span class="content-header">Ссылки</span>
				</div>
				<div id="WhatReference-article" class="container-content">
					<span class="content-subheader">Что такое ссылка?</span>
					Ссылка - это псевдоним (другое имя) для объекта.

					Ссылки часто используются для передачи параметра по ссылке:
					<div class="code-container">
						<pre>void swap(int& i, int& j)
{
	int tmp = i;
	i = j;
	j = tmp;
}

int main()
{
	int x, y;
	// ...
	swap(x,y);
}</pre>
					</div>
					В этом примере i и j - псевдонимы для переменных x и y функции main. Другими словами, i - это x. Не
					указатель на x и не копия x, а сам x. Все, что вы делаете с i, проделывается с x, и наоборот.
					<br><br>
					Вот таким образом вы как программист должны воспринимать ссылки. Теперь, рискуя дать вам неверное
					представление, несколько слов о том, каков механизм работы ссылок. В основе ссылки i на объект x -
					лежит, как правило, просто машинный адрес объекта x. Но когда вы пишете i++, компилятор генерирует
					код, который инкрементирует x. В частности, сам адрес, который компилятор использует, чтобы найти x,
					остается неизменным. Программист на С может думать об этом, как если бы использовалась передача
					параметра по указателю, в духе языка С, но, во-первых, & (взятие адреса) было бы перемещено из
					вызывающей функции в вызываемую, и, во-вторых, в вызываемой функции были бы убраны *
					(разыменование). Другими словами, программист на С может думать об i как о макроопределении для
					(*p), где p - это указатель на x (т.е., компилятор автоматически разыменовывает подлежащий
					указатель: i++ заменяется на (*p)++, а i = 7 на *p = 7).
					<br><br>
					Важное замечание: несмотря на то что в качестве ссылки в окончательном машинном коде часто
					используется адрес, не думайте о ссылке просто как о забавно выглядящем указателе на объект. Ссылка
					- это объект. Это не указатель на объект и не копия объекта. Это сам объект.
				</div>
				<div id="AssignRef-article" class="container-content">
					<span class="content-subheader">Что происходит в результате присваивания ссылке?</span>
					Вы меняете состояние ссыльного объекта (того, на который ссылается ссылка).
					<br><br>
					Помните: ссылка - это сам объект, поэтому, изменяя ссылку, вы меняете состояние объекта, на который
					она ссылается. На языке производителей компиляторов ссылка - это lvalue (left value - значение,
					которое может появиться слева от оператора присваивания).
				</div>
				<div id="ReturnRef-article" class="container-content">
					<span class="content-subheader">Что происходит, когда я возвращаю из функции ссылку?</span>
					В этом случае вызов функции может оказаться с левой стороны оператора (операции) присваивания.

					На первый взгляд, такая запись может показаться странной. Например, запись f() = 7 выглядит
					бессмысленной. Однако, если a - это объект класса Array, для большинства людей запись a[i] = 7
					является осмысленной, хотя a[i] - это всего лишь замаскированный вызов функции
					Array::operator[](int), которая является оператором обращения по индексу для класса Array:

					<div class="code-container">
						<pre>
class Array {
	public:
	int size() const;
	float& operator[] (int index);
	// ...
};

int main()
{
	Array a;
	for (int i = 0; i < a.size(); ++i)
	a[i] = 7; // В этой строке вызывается Array::operator[](int)
}
</pre>
					</div>
				</div>
				<div id="ResetRef-article" class="container-content">
					<span class="content-subheader">Как можно переустановить ссылку, чтобы она ссылалась на другой объект?</span>
					Невозможно в принципе.
					<br><br>
					Невозможно отделить ссылку от ее объекта.
					<br><br>
					В отличие от указателя, ссылка, как только она привязана к объекту, не может быть "перенаправлена"
					на другой объект. Ссылка сама по себе ничего не представляет, у нее нет имени, она сама - это другое
					имя для объекта. Взятие адреса ссылки дает адрес объекта, на который она ссылается. Помните: ссылка
					- это объект, на который она ссылается.
					<br><br>
					С этой точки зрения, ссылка похожа на const указатель [18.5], такой как int* const p (в отличие от
					указателя на const [18.4], такого как const int* p). Несмотря на большую схожесть, не путайте ссылки
					с указателями - это не одно и то же.
				</div>
				<div id="RefOrPointer-article" class="container-content">
					<span class="content-subheader">В каких случаях мне стоит использовать ссылки, и в каких - указатели?</span>
					Используйте ссылки, когда можете, а указатели - когда это необходимо.
					<br><br>
					Ссылки обычно предпочтительней указателей, когда вам ненужно их "перенаправлять" [8.4]. Это обычно
					означает, что ссылки особенно полезны в открытой (public) части класса. Ссылки обычно появляются на
					поверхности объекта, а указатели спрятаны внутри.
					<br><br>
					Исключением является тот случай, когда параметр или возвращаемый из функции объект требует выделения
					"охранного" значения для особых случаев. Это обычно реализуется путем взятия/возвращения указателя,
					и обозначением особого случая при помощи передачи нулевого указателя (NULL). Ссылка же не может
					ссылаться на разыменованный нулевой указатель.
					<br><br>
					Примечание: программисты с опытом работы на С часто недолюбливают ссылки, из-за того что передача
					параметра по ссылке явно никак не обозначается в вызывающем коде. Однако с обретением некоторого
					опыта работы на С++, они осознают, что это одна из форм сокрытия информации, которая является скорее
					преимуществом, чем недостатком. Т.е., программисту следует писать код в терминах задачи, а не
					компьютера (programmers should write code in the language of the problem rather than the language of
					the machine).<br><br>
				</div>
			</div>
			<div id="Inline-article" class="centered-container bordered-container">
				<div class="container-content">
					<span class="content-header">Встроенные (inline) функции</span>
					<div id="WhatInline" class="container-content">
						<span class="content-subheader">Что такое встроенная функция?</span>
						Встроенная функция - это функция, код которой прямо вставляется в том месте, где она вызвана.
						Как и макросы, определенные через #define, встроенные функции улучшают производительность за
						счет стоимости вызова и (особенно!) за счет возможности дополнительной оптимизации ("процедурная
						интеграция").
					</div>
					<div id="InlineSafety" class="container-content">
						<span class="content-subheader">Как встроенные функции могут влиять на соотношение безопасности и скорости?</span>
						В обычном С вы можете получить "инкапсулированные структуры", помещая в них указатель на void, и
						заставляя его указывать на настоящие данные, тип которых неизвестен пользователям структуры.
						Таким образом, пользователи не знают, как интерпретировать эти данные, а функции доступа
						преобразуют указатель на void к нужному скрытому типу. Так достигается некоторый уровень
						инкапсуляции.
						<br><br>
						К сожалению, этот метод идет вразрез с безопасностью типов, а также требует вызова функции для
						доступа к любым полям структуры (если вы позволили бы прямой доступ, то его мог бы получить кто
						угодно, поскольку будет известно, как интерпретировать данные, на которые указывает void*. Такое
						поведение со стороны пользователя приведет к сложностям при последующем изменении структуры
						подлежащих данных).
						<br><br>
						Стоимость вызова функции невелика, но дает некоторую прибавку. Классы С++ позволяют встраивание
						функций, что дает вам безопасность инкапсуляции вместе со скоростью прямого доступа. Более того,
						типы параметры встраиваемых функций проверяются компилятором, что является преимуществом по
						сравнению с (?)сишными #define макросами.
					</div>
					<div id="WhyInline" class="container-content">
						<span class="content-subheader">Зачем мне использовать встроенные функции? Почему не использовать просто #define макросы?</span>
						Поскольку #define макросы опасны [9.3], опасны [34.1], опасны [34.2], опасны [34.3].
						<br><br>
						В отличие от #define макросов, встроенные (inline) функции неподвержены известным ошибкам
						двойного вычисления, поскольку каждый аргумент встроенной функции вычисляется только один раз.
						Другими словами, вызов встроенной функции - это то же самое что и вызов обычной функции, только
						быстрее:
						<div class="code-container">
							<pre>
// Макрос, возвращающий модуль (абсолютное значение) i
#define unsafe(i) \
	( (i) >= 0 ? (i) : -(i) )

// Встроенная функция, возвращающая абсолютное значение i
inline int safe(int i)
{
	return i >= 0 ? i : -i;
}

int f();

void userCode(int x)
{
	int ans;
	ans = unsafe(x++); // Ошибка! x инкрементируется дважды
	ans = unsafe(f()); // Опасно! f() вызывается дважды
	ans = safe(x++); // Верно! x инкрементируется один раз
	ans = safe(f()); // Верно! f() вызывается один раз
}
							</pre>
						</div>
						Также, в отличие от макросов, типы аргументов встроенных функций проверяются, и выполняются все
						необходимые преобразования.
						<br><br>
						Макросы вредны для здоровья; не используйте их, если это не необходимо
					</div>
					<div id="HowDefineInline" class="container-content">
						<span class="content-subheader">Что сделать, чтобы определить функцию - не член класса как встроенную?</span>
						Когда вы объявляете встроенную функцию, это выглядит как обычное объявление функции:
						<br><br>
						<div class="code-container">void f(int i, char c);</div>
						Но перед определением встроенной функции пишется слово inline, и само определение помещается в
						заголовочный файл:

						<div class="code-container">
							<pre>
inline void f(int i, char c)
{
	// ...
}</pre>
						</div>
						Примечание: Необходимо, чтобы определение встроенной функции (часть между {...}) была помещена в
						заголовочный файл, за исключением того случая, когда функция используется только в одном .cpp
						файле. Если вы помещаете определение встроенной функции в .cpp файл, а вызываете ее из другого
						.cpp файла, то вы получаете ошибку "unresolved external" ("ненайденный внешний объект") от
						компоновщика (linker).
						<br><br>
						(Примечание переводчика: На всякий случай уточню, что само помещение определения функции в
						заголовочный файл НЕ делает ее встроенной. Это требуется только для того, чтобы тело функции
						было видно во всех местах, где она вызывается. Иначе невозможно обеспечить встраивание функции.
						- YM)
					</div>
					<div id="HowToInlineClassMem" class="container-content">
						<span class="content-subheader">Как сделать встроенной функцию - член класса?</span>
						Когда вы объявляете встроенную функцию - член класса, это выглядит как обычное объявление
						функции - члена:

						<div class="code-container">
<pre>class Fred {
	public:
	void f(int i, char c);
};</pre>
						</div>
						Но когда перед определением встроенной функции пишется слово inline, а само определение
						помещается в заголовочный файл:

						<div class="code-container">
<pre>inline void Fred::f(int i, char c)
{
	// ...
}</pre>
						</div>
						Примечание: Необходимо, чтобы определение встроенной функции (часть между {...}) была помещена в
						заголовочный файл, за исключением того случая, когда функция используется только в одном .cpp
						файле. Если вы помещаете определение встроенной функции в .cpp файл, а вызываете ее из другого
						.cpp файла, то вы получаете ошибку "unresolved external" ("ненайденный внешний объект") от
						компоновщика (linker).
					</div>
					<div id="AnotherWayDefineClassMem" class="container-content">
						<span class="content-subheader">Есть ли другой способ определить встроенную функцию - член класса?</span>
						Да, определите функцию-член класса в теле самого класса:

						<div class="code-container">
<pre>class Fred {
	public:
	void f(int i, char c)
	{
		// ...
	}
};</pre>
						</div>
						Хотя такой вид определения проще для создателя класса, но он вызывает определенные трудности для
						пользователя, поскольку здесь смешивается, что делает класс и как он это делает. Из-за этого
						неудобства предпочтительно определять функции-члены класса вне тела класса, используя слово
						inline [9.5]. Причина такого предпочтения проста: как правило, множество людей используют
						созданный вами класс, но только один человек пишет его (вы); предпочтительно делать вещи,
						облегчающие жизнь многим.
					</div>
					<div id="IsInlineSpeedUp" class="container-content">
						<span class="content-subheader">Обязательно ли встроенные функции приведут к увеличению производительности?</span>
						Нет.
						<br><br>
						Слишком большое количество встроенных функций может привести к увеличению размера кода, что в
						свою очередь может оказать негативное влияние на скорость в системах со страничной организацией
						памяти.<br><br>
					</div>
				</div>
			</div>
			<div id="Constructors" class="centered-container bordered-container">
				<div class="container-content">
					<span class="content-header">Конструкторы</span>
					<div id="WhatCtor" class="container-content">
						<span class="content-subheader">Что такое конструкторы?</span>
						Конструкторы делают объекты из ничего.
						<br><br>
						Конструкторы похожи на инициализирующие функции. Они превращают свалку случайных бит в
						работающий объект. В минимальном случае, они инициализируют используемые переменные класса.
						Также они могут выделять ресурсы (память, файлы, флажки, сокеты и т. п.).
						<br><br>
						"ctor" - часто используемое сокращение для слова конструктор.
						<br><br>
					</div>
					<div id="CtorOrInstanceDiff" class="container-content">
						<span class="content-subheader">Есть ли разница между объявлениями List x; и List x();?</span>
						Огромная!

						Предположим, что List - это имя класса. Тогда функция f() объявляет локальный объект типа List с
						именем x:

						<div class="code-container">
<pre>void f()
{
	List x; // Локальный объект с именем x (класса List)
	// ...
}</pre>
						</div>
						Но функция g() объявляет функцию x(), которая возвращает объект типа List:

						<div class="code-container"><pre>void g()
{
	List x(); // Функция с именем x (возвращающая List)
	// ...
}</pre>
						</div>

					</div>
					<div id="CallOtherCtor" class="container-content">
						<span class="content-subheader">Как из одного конструктора вызвать другой конструктор для инициализации этого объекта?</span>
						(Имеются в виду несколько перегруженных конструкторов для одного объекта - примечание
						переводчика.)
						<br><br>
						Никак.
						<br><br>
						Проблема вот в чем: если вы вызовете другой конструктор, компьютер создаст и проинициализирует
						временный объект, а не объект, из которого вызван конструктор. Вы можете совместить два
						конструктора, используя значения параметров по умолчанию, или вы можете разместить общий для
						двух конструкторов код в закрытой (private) функции - члене init().
					</div>
					<div id="AppearanceCtor" class="container-content">
						<span class="content-subheader">Всегда ли конструктор по умолчанию для Fred выглядит как Fred::Fred()?</span>
						Нет. Конструктор по умолчанию - это конструктор, который можно вызывать без аргументов. Таким
						образом, конструктор без аргументов безусловно является конструктором по умолчанию:

						<div class="code-container"><pre>class Fred {
	public:
	Fred(); // Конструктор по умолчанию: может вызываться без аргументов
	// ...
};</pre>
						</div>
						Однако возможно (и даже вероятно), что конструктор по умолчанию может принимать аргументы, при
						условии что для всех них заданы значения по умолчанию:

						<div class="code-container"><pre>class Fred {
	public:
	Fred(int i=3, int j=5); // Конструктор по умолчанию: может вызываться без аргументов
	// ...
};</pre>
						</div>

					</div>
					<div id="CtorInArrays" class="container-content">
						<span class="content-subheader">Какой конструктор будет вызван, если я создаю массив объектов типа Fred?</span>
						Конструктор по умолчанию [10.4] для класса Fred (за исключением случая, описанного ниже)
						<br><br>
						Не существует способа заставить компилятор вызвать другой конструктор (за исключением способа,
						описанного ниже). Если у вашего класса Fred нет конструктора по умолчанию [10.4], то при попытке
						создания массива объектов типа Fred вы получите ошибку при компиляции.

						<div class="code-container"><pre>class Fred {
public:
	Fred(int i, int j);
	// ... предположим, что для класса Fred нет конструктора по умолчанию [10.4]...
};

int main()
{
	Fred a[10]; // ОШИБКА: У Fred нет конструктора по умолчанию
	Fred* p = new Fred[10]; // ОШИБКА: У Fred нет конструктора по умолчанию
}</pre>
						</div>
						Однако если вы создаете, пользуясь STL [32.1], vector
						&lt;Fred&gt; вместо простого массива (что вам скорее всего и следует делать, поскольку массивы
						опасны
						[21.5]), вам не нужно иметь конструктор по умолчанию в классе Fred, поскольку вы можете
						задать объект типа Fred для инициализации элементов вектора:

						<div class="code-container"><pre>#include &lt;vector&gt;
using namespace std;

int main()
{
	vector &lt;Fred&gt; a(10, Fred(5,7));
	// Десять объектов типа Fred
	// будут инициализированы Fred(5,7).
	// ...
}</pre>
						</div>
						Хотя вам следует пользоваться векторами, а не массивами, иногда бывают ситуации,
						когда необходим именно массив. Специально для таких случаев существует способ
						записи явной инициализации массивов. Вот как это выглядит:

						<div class="code-container"><pre>class Fred {
public:
	Fred(int i, int j);
	// ... предположим, что для класса Fred
	// нет конструктора по умолчанию [10.4]...
};

int main()
{
	Fred a[10] = {
	Fred(5,7), Fred(5,7), Fred(5,7), Fred(5,7), Fred(5,7),
	Fred(5,7), Fred(5,7), Fred(5,7), Fred(5,7), Fred(5,7)
};

	// Десять объектов массива Fred
	// будут инициализированы Fred(5,7).
	// ...
}</pre>
						</div>
						Конечно, вам не обязательно использовать Fred(5,7) для каждого элемента. Вы
						можете использовать любые числа или даже параметры и другие переменные. Суть в
						том, что такая запись (a) возможна, но (б) не так хороша, как запись для вектора.
						Помните: массивы опасны [21.5]. Если у вы не вынуждены использовать массивы -
						используйте вектора.
					</div>
					<div id="CtorInitList" class="container-content">
						<span class="content-subheader">Должны ли мои конструкторы использовать "списки инициализации" или "присваивания значений"?</span>
						Конструкторы должны инициализировать все члены в списках инициализации.
						<br><br>
						Например, пусть конструктор инициализирует член x_, используя список инициализации: Fred::Fred()
						: x_(какое-то-выражение) { }. С точки зрения производительности важно заметить, что
						какое-то-выражение не приводит к созданию отдельного объекта для копирования его в x_: если типы
						совпадают, то какое-то-выражение будет создано прямо в x_.
						<br><br>
						Напротив, следующий конструктор использует присваивание: Fred::Fred() { x_ = какое-то-выражение;
						}. В этом случае какое-то-выражение приводит к созданию отдельного временного объекта, который
						потом передается в качестве параметра оператору присваивания объекта x_, а потом уничтожается
						при достижении точки с запятой. Это неэффективно.
						<br><br>
						Есть и еще один источник неэффективности: во втором случае (с присваиванием) конструктор по
						умолчанию для объекта (неявно вызванный до { тела конструктора) мог, например, выделить по
						умолчанию некоторое количество памяти или открыть файл. Вся эта работа окажется проделанной
						впустую, если какое-то-выражение и/или оператор присваивания привели к закрытию этого файла
						и/или освобождению памяти (например, если конструктор по умолчанию выделил недостаточно памяти
						или открыл не тот файл).
						<br><br>
						Выводы: при прочих равных условиях ваш код будет более быстрым, если вы используете списки
						инициализации, а не операторы присваивания.
					</div>
					<div id="ThisInCtor" class="container-content">
						<span class="content-subheader">Можно ли пользоваться указателем this в конструкторе?</span>
						Некоторые люди не рекомендуют использовать указатель this в конструкторе, потому что объект, на
						который указывает this еще не полностью создан. Тем не менее, при известной осторожности, вы
						можете использовать this в конструкторе (в {теле} и даже в списке инициализации [10.6]).
						<br><br>
						Как только вы попали в {тело} конструктора, легко себе вообразить, что можно использовать
						указатель this, поскольку все базовые классы и все члены уже полностью созданы. Однако даже
						здесь нужно быть осторожным. Например, если вы вызываете виртуальную функцию (или какую-нибудь
						функцию, которая в свою очередь вызывает виртуальную функцию) для этого объекта, мы можете
						получить не совсем то, что хотели [23.1].
						<br><br>
						На самом деле вы можете пользоваться указателем this даже в списке инициализации конструктора
						[10.6], при условии что вы достаточно осторожны, чтобы по ошибке не затронуть каких-либо
						объектов-членов или базовых классов, которые еще не были созданы. Это требует хорошего знания
						деталей порядка инициализации в конструкторе, так что не говорите, что вас не предупреждали.
						Самое безопасное - сохранить где-нибудь значение указателя this и воспользоваться им потом. [Не
						понял, что они имеют в виду. - YM]
					</div>
					<div id="NamedCtor" class="container-content">
						<span class="content-subheader">Что такое "именованный конструктор" ("Named Constructor Idiom")?</span>
						Это техника обеспечивает более безопасный и интуитивно понятный для пользователей процесс
						создания для вашего класса.
						<br><br>
						Проблема заключается в том, что конструкторы всегда носят то же имя, что и их класс. Таким
						образом, единственное различие между конструкторами одного класса - это их список параметров. И
						существует множество случаев, когда разница между конструкторами становится весьма
						незначительной, что ведет к ошибкам.
						<br><br>
						Для использования именованных конструкторов вы объявляете все конструкторы класса в закрытом
						(private:) или защищенном (protected:) разделе, и пишете несколько открытых (public:)
						статических методов, которые возвращают объект. Эти статические методы и называются
						"именованными конструкторами". В общем случае существует по одному такому конструктору на каждый
						из различных способов создания класса.
						<br><br>
						Например, допустим, у нас есть класс Point, который представляет точку на плоскости X - Y.
						Существуют два распространенных способа задания двумерных координат: прямоугольные координаты (X
						+ Y) и полярные координаты (радиус и угол). (Не беспокойтесь, если вы не разбираетесь в таких
						вещах, суть примера не в этом. Суть в том, что существует несколько способов создания объекта
						типа Point.) К сожалению, типы параметров для этих двух координатных систем одни и те же: два
						числа с плавающей точкой. Это привело бы к неоднозначности, если бы мы сделали перегруженные
						конструкторы:

						<div class="code-container"><pre>class Point {
public:
	Point(float x, float y); // Прямоугольные координаты
	Point(float r, float a); // Полярные координаты (радиус и угол)
	// ОШИБКА: Неоднозначная перегруженная функция: Point::Point(float,float)
};

int main()
{
	Point p = Point(5.7, 1.2); // Неоднозначность: Какая координатная система?
}</pre>
						</div>
						Одним из путей решения этой проблемы и являются именованные конструкторы:

						<div class="code-container"><pre>#include &lt;math.h&gt; // Для sin() и cos()

class Point {
public:
	static Point rectangular(float x, float y); // Прямоугольные координаты
	static Point polar(float radius, float angle); // Полярные координаты
	// Эти статические члены называются "именованными конструкторами"
	// ...
private:
	Point(float x, float y); // Прямоугольные координаты
	float x_, y_;
};

inline Point::Point(float x, float y)
: x_(x), y_(y) { }

inline Point Point::rectangular(float x, float y)
{ return Point(x, y); }

inline Point Point::polar(float radius, float angle)
{ return Point(radius*cos(angle), radius*sin(angle)); }</pre>
						</div>
						Теперь у пользователей класса Point появился способ ясного и недвусмысленного создания
						точек в обеих системах координат:

						<div class="code-container"><pre>int main()
{
	Point p1 = Point::rectangular(5.7, 1.2); // Ясно, что прямоугольные координаты
	Point p2 = Point::polar(5.7, 1.2); // Ясно, что полярные координаты
}</pre>
						</div>
						Обязательно помещайте ваши конструкторы в защищенный (protected:) раздел, если вы
						планируете создавать производные классы от Fred. [Видимо, ошибка. Хотели сказать -
						Point. - YM]
						<br><br>
						Именованные конструкторы также можно использовать том в случае, если вы хотите, чтобы
						ваши объекты всегда создавались динамически (посредством new [16.19]).
					</div>
					<div id="StaticCtorInit" class="container-content">
						<span class="content-subheader">Почему я не могу проинициализировать статический член класса в списке инициализации конструктора?</span>
						Потому что вы должны отдельно определять статические данные классов.
						<br><br>
						Fred.h:

						<div class="code-container"><pre>class Fred {
public:
	Fred();
	// ...
private:
	int i_;
	static int j_;
};</pre>
						</div>
						Fred.cpp (или Fred.C, или еще как-нибудь):

						<div class="code-container"><pre>Fred::Fred()
	: i_(10), // Верно: вы можете (и вам следует)
		   // инициализировать переменные - члены класса таким образом
	j_(42) // Ошибка: вы не можете инициализировать
		 // статические данные класса таким образом
	{
		// ...
	}

	// Вы должны определять статические данные класса вот так:
	int Fred::j_ = 42;</pre>
						</div>

					</div>
					<div id="UndefinedExternal" class="container-content">
						<span class="content-subheader">Почему классы со статическими данными получают ошибки при компоновке?</span>
						Потому что статические данные класса должны быть определены только в одной единице трансляции
						[10.9]. Если вы не делаете этого, вы вероятно получите при компоновке ошибку "undefined
						external" ("внешний объект не определен"). Например:

						<div class="code-container"><pre>// Fred.h

class Fred {
public:
	// ...
private:
	static int j_; // Объявляет статическую переменную Fred::j_
	// ...
};</pre>
						</div>
						Компоновщик пожалуется ("Fred::j_ is not defined" / "Fred::j_ не определено"), если вы не
						напишите определение (в отличие от просто объявления) Fred::j_ в одном (и только в одном) из
						исходных файлов:

						<div class="code-container"><pre>// Fred.cpp

#include "Fred.h"

int Fred::j_ = некоторое_выражение_приводимое_к_int;

// По-другому, если вы желаете получить неявную инициализацию нулем для int:
// int Fred::j_;</pre>
						</div>
						Обычное место для определения статических данных класса Fred - это файл Fred.cpp (или Fred.C,
						или другое используемое вами расширение).
					</div>
					<div id="StaticInitOrder" class="container-content">
						<span class="content-subheader">Что такое ошибка в порядке статической инициализации ("static initialization order fiasco")?</span>
						Незаметный и коварный способ убить ваш проект.
						<br><br>
						Ошибка порядка статической инициализации - это очень тонкий и часто неверно воспринимаемый
						аспект С++. К сожалению, подобную ошибку очень сложно отловить, поскольку она происходит до
						вхождения в функцию main().
						<br><br>
						Представьте себе, что у вас есть два статических объекта x и y, которые находятся в двух разных
						исходных файлах, скажем x.cpp и y.cpp. И путь конструктор объекта y вызывает какой-либо метод
						объекта x.
						<br><br>
						Вот и все. Так просто.
						<br><br>
						Проблема в том, что у вас ровно пятидесятипроцентная возможность катастрофы. Если случится, что
						единица трансляции с x.cpp будет проинициализирована первой, то все в порядке. Если же первой
						будет проинициализирована единица трансляции файла y.cpp, тогда конструктор объекта y будет
						запущен до конструктора x, и вам крышка. Т.е., конструктор y вызовет метод объекта x, когда сам
						x еще не создан.
						<br><br>
						Идите работать в МакДональдс. Делайте Биг-Маки, забудьте про классы.
						<br><br>
						Если вам нравится играть в русскую рулетку с барабаном, на половину заполненным пулями, то вы
						можете дальше не читать. Если же вы хотите увеличить свои шансы на выживание, систематически
						устраняя проблемы в зародыше, вы, вероятно, захотите прочесть ответ на следующий вопрос [10.12].
						<br><br>
						Примечание: ошибки статической инициализации не распространяются на базовые/встроенные типы,
						такие как int или char*. Например, если вы создаете статическую переменную типа float, у вас не
						будет проблем с порядком инициализации. Проблема возникает только тогда, когда у вашего
						статического или глобального объекта есть конструктор.
					</div>
					<div id="AvoidInitOrderErr" class="container-content">
						<span class="content-subheader">Как предотвратить ошибку в порядке статической инициализации?</span>
						Используйте "создание при первом использовании", то есть, поместите ваш статический объект в
						функцию.
						<br><br>
						Представьте себе, что у нас есть два класса Fred и Barney. Есть глобальный объект типа Fred, с
						именем x, и глобальный объект типа Barney, с именем y. Конструктор Barney вызывает метод
						goBowling() объекта x. Файл x.cpp содержит определение объекта x:

						<div class="code-container"><pre>// File x.cpp
#include "Fred.hpp"
Fred x;</pre>
						</div>
						Файл y.cpp содержит определение объекта y:

						<div class="code-container"><pre>// File y.cpp
#include "Barney.hpp"
Barney y;</pre>
						</div>
						Для полноты представим, что конструктор Barney::Barney() выглядит следующим образом:

						<div class="code-container"><pre>// File Barney.cpp
#include "Barney.hpp"

Barney::Barney()
{
	// ...
	x.goBowling();
	// ...
}</pre>
						</div>
						Как описано выше [10.11], проблема случается, если y создается раньше, чем x, что происходит в
						50% случаев, поскольку x и y находятся в разных исходных файлах.
						<br><br>
						Есть много решений для этой проблемы, но одно очень простое и переносимое - заменить глобальный
						объект Fred x, глобальной функцией x(), которая возвращает объект типа Fred по ссылке.

						<div class="code-container"><pre>// File x.cpp

#include "Fred.hpp"

Fred& x()
{
	static Fred* ans = new Fred();
	return *ans;
}</pre>
						</div>
						Поскольку локальные статические объекты создаются в момент, когда программа в процессе работы в
						первый раз проходит через точку их объявления, инструкция new Fred() в примере выше будет
						выполнена только один раз: во время первого вызова функции x(). Каждый последующий вызов
						возвратит тот же самый объект Fred (тот, на который указывает ans). И далее все случаи
						использования объекта x замените на вызовы функции x():

						<div class="code-container"><pre>// File Barney.cpp
#include "Barney.hpp"

Barney::Barney()
{
	// ...
	x().goBowling();
	// ...
}</pre>
						</div>
						Это и называется "создание при первом использовании", глобальный объект Fred создается при
						первом обращении к нему.
						<br><br>
						Отрицательным моментом этой техники является тот факт, что объект Fred нигде не уничтожается.
						Книга C++ FAQ Book описывает дополнительную технику, которая позволяет решить и эту проблему
						(правда, ценой появления возможный ошибок порядка статической деинициализации).
						<br><br>
						Примечание: ошибки статической инициализации не распространяются на базовые/встроенные типы,
						такие как int или char*. Например, если вы создаете статическую переменную типа float, у вас не
						будет проблем с порядком инициализации. Проблема возникает только тогда, когда у вашего
						статического или глобального объекта есть конструктор.
					</div>
					<div id="AssertStaticInit" class="container-content">
						<span class="content-subheader">Как бороться с ошибками порядка статической инициализации объектов - членов класса?</span>
						Используйте ту же самую технику, которая описана в [10.12], но вместо глобальной функции
						используйте статическую функцию-член.
						<br><br>
						Предположим, у вас есть класс X, в котором есть статический объект Fred:

						<div class="code-container"><pre>// File X.hpp

class X {
public:
	// ...

private:
	static Fred x_;
};</pre>
						</div>
						Естественно, этот статический член инициализируется отдельно:

						<div class="code-container"><pre>// File X.cpp

#include "X.hpp"

Fred X::x_;</pre>
						</div>
						Опять же естественно, объект Fred будет использован в одном или нескольких методах класса X:

						<div class="code-container"><pre>void X::someMethod()
{
	x_.goBowling();
}</pre>
						</div>
						Проблема проявится, если кто-то где-то каким-либо образом вызовет этот метод, до того как объект
						Fred будет создан. Например, если кто-то создает статический объект X и вызывает его
						someMethod() во время статической инициализации, то ваша судьба всецело находится в руках
						компилятора, который либо создаст X::x_, до того как будет вызван someMethod(), либо же только
						после.
						<br><br>
						(Должен заметить, что ANSI/ISO комитет по C++ работает над этой проблемой, но компиляторы,
						которые работают в соответствии с последними изменениями, пока недоступны; возможно, в будущем в
						этом разделе будут сделаны дополнения в связи с изменившейся ситуацией.)
						<br><br>
						В любом случае, всегда можно сохранить переносимость (и это абсолютно безопасный метод), заменив
						статический член X::x_ на статическую функцию-член:

						<div class="code-container"><pre>// File X.hpp

class X {
public:
	// ...

private:
	static Fred& x();
};</pre>
						</div>
						Естественно, этот статический член инициализируется отдельно:

						<div class="code-container"><pre>// File X.cpp

#include "X.hpp"

Fred& X::x()
{
	static Fred* ans = new Fred();
	return *ans;
}</pre>
						</div>
						После чего вы просто меняете все x_ на x():

						<div class="code-container"><pre>void X::someMethod()
{
	x().goBowling();
}</pre>
						</div>
						Если для вас крайне важна скорость работы программы и вас беспокоит необходимость
						дополнительного вызова функции для каждого вызова X::someMethod(), то вы можете сделать static
						Fred&. Как вы помните, статические локальные переменные инициализируются только один раз (при
						первом прохождении программы через их объявление), так что X::x() теперь будет вызвана только
						один раз: во время первого вызова X::someMethod():

						<div class="code-container"><pre>void X::someMethod()
{
	static Fred& x = X::x();
	x.goBowling();
}</pre>
						</div>
						Примечание: ошибки статической инициализации не распространяются на базовые/встроенные типы,
						такие как int или char*. Например, если вы создаете статическую переменную типа float, у вас не
						будет проблем с порядком инициализации. Проблема возникает только тогда, когда у вашего
						статического или глобального объекта есть конструктор.
					</div>
					<div id="HandleCtorError" class="container-content">
						<span class="content-subheader">Как мне обработать ошибку, которая произошла в конструкторе?</span>
						Сгенерируйте исключение. Смотрите подробности в [17.1].
						<br><br>
					</div>
				</div>
			</div>
			<div id="Destructors" class="centered-container bordered-container">
				<div class="container-content">
					<span class="content-header">Деструкторы</span>
					<div id="WhatDestructor" class="container-content">
						<span class="content-subheader">Что такое деструктор?</span>
						Деструктор - это исполнение последней воли объекта.
						<br><br>
						Деструкторы используются для высвобождения занятых объектом ресурсов. Например, класс Lock может
						заблокировать ресурс для эксклюзивного использования, а его деструктор этот ресурс освободить.
						Но самый частый случай - это когда в конструкторе используется new, а в деструкторе - delete.
						<br><br>
						Деструктор это функция "готовься к смерти". Часто слово деструктор сокращается до dtor.
					</div>
					<div id="DestructorOrderObj" class="container-content">
						<span class="content-subheader">В каком порядке вызываются деструкторы для локальных объектов?</span>
						В порядке обратном тому, в каком эти объекты создавались: первым создан - последним будет
						уничтожен.
						<br><br>
						В следующем примере деструктор для объекта b будет вызван первым, а только затем деструктор для
						объекта a:

						<div class="code-container"><pre>void userCode()
{
	Fred a;
	Fred b;
	// ...
}</pre>
						</div>
					</div>
					<div id="DestructorOrderArr" class="container-content">
						<span class="content-subheader">В каком порядке вызываются деструкторы для массивов объектов?</span>
						В порядке обратном созданию: первым создан - последним будет уничтожен.
						<br><br>
						В следующем примере порядок вызова деструкторов будет таким: a[9], a[8], ..., a[1], a[0]:

						<div class="code-container"><pre>void userCode()
{
	Fred a[10];
	// ...
}</pre>
						</div>
					</div>
					<div id="OverloadDestructor" class="container-content">
						<span class="content-subheader">Могу ли я перегрузить деструктор для своего класса?</span>
						Нет.
						<br><br>
						У каждого класса может быть только один деструктор. Для класса Fred он всегда будет называться
						Fred::~Fred(). В деструктор никогда не передаётся никаких параметров, и сам деструктор никогда
						ничего не возвращает.
						<br><br>
						Всё равно вы не смогли бы указать параметры для деструктора, потому что вы никогда на вызываете
						деструктор напрямую [11.5] (точнее, почти никогда [11.10]).
					</div>
					<div id="ExplicitCallDestructor" class="container-content">
						<span class="content-subheader">Могу ли я явно вызвать деструктор для локальной переменной?</span>
						Нет!
						<br><br>
						Деструктор всё равно будет вызван еще раз при достижении закрывающей фигурной скобки } конца
						блока, в котором была создана локальная переменная. Этот вызов гарантируется языком, и он
						происходит автоматически; нет способа этот вызов предотвратить. Но последствия повторного вызова
						деструктора для одного и того же объекта могут быть плачевными. Бах! И вы покойник...
					</div>
					<div id="ExplicitCallDestructorVar" class="container-content">
						<span class="content-subheader">А что если я хочу, чтобы локальная переменная "умерла" раньше закрывающей фигурной скобки? Могу ли я при крайней необходимости вызвать деструктор для локальной переменной?</span>
						Нет! [Смотрите ответ на предыдущий вопрос [11.5]].

						Предположим, что (желаемый) побочный эффект от вызова деструктора для локального объекта File
						заключается в закрытии файла. И предположим, что у нас есть экземпляр f класса File и мы хотим,
						чтобы файл f был закрыт раньше конца своей области видимости (т.е., раньше }):

						<div class="code-container"><pre>void someCode()
{
	File f;
	
	// ... [Этот код выполняется при открытом f] ...
	
	// <-- Нам нужен эффект деструктора f здесь
	// ... [Этот код выполняется после закрытия f] ...
}</pre>
						</div>
						Для этой проблемы есть простое решение, которое мы покажем в [11.7]. Но пока запомните только
						следующее: нельзя явно вызывать деструктор [11.5].
					</div>
					<div id="ExplicitCallDestructorVarSol" class="container-content">
						<span class="content-subheader">Хорошо, я не буду явно вызывать деструктор. Но как мне справиться с этой проблемой?</span>
						[Также смотрите ответ на предыдущий вопрос [11.6]].
						<br><br>
						Просто поместите вашу локальную переменную в отдельный блок {...}, соответствующий необходимому
						времени жизни этой переменной:
						<div class="code-container"><pre>void someCode()
{
	{
		File f;
		// ... [В этом месте f еще открыт] ...
	}
	// ^-- деструктор f будет автомагически вызван здесь!

	// ... [В этом месте f уже будет закрыт] ...
}</pre>
						</div>
					</div>
					<div id="ExplicitCallDestructorVarOtherSol" class="container-content">
						<span class="content-subheader">А что делать, если я не могу поместить переменную в отдельный блок?</span>
						В большинстве случаев вы можете воспользоваться дополнительным блоком {...} для ограничения
						времени жизни вашей переменной [11.7]. Но если по какой-то причине вы не можете добавить блок,
						добавьте функцию-член, которая будет выполнять те же действия, что и деструктор. Но помните: вы
						не можете сами вызывать деструктор!
						<br><br>
						Например, в случае с классом File, вы можете добавить метод close(). Обычный деструктор будет
						вызывать close(). Обратите внимание, что метод close() должен будет как-то отмечать объект File,
						с тем чтобы последующие вызовы не пытались закрыть уже закрытый файл. Например, можно
						устанавливать переменную-член fileHandle_ в какое-нибудь неиспользуемое значение, типа -1, и
						проверять в начале, не содержит ли fileHandle_ значение -1.

						<div class="code-container"><pre>class File {
public:
	void close();
	~File();
	// ...
private:
	int fileHandle_; // fileHandle_ >= 0 если/только если файл открыт
};

File::~File()
{
	close();
}

void File::close()
{
	if (fileHandle_ >= 0) {
		// ... [Вызвать системную функцию для закрытия файла] ...
		fileHandle_ = -1;
	}
}</pre>
						</div>
						Обратите внимание, что другим методам класса File тоже может понадобиться проверять, не
						установлен ли fileHandle_ в -1 (т.е., не закрыт ли файл).
						<br><br>
						Также обратите внимание, что все конструкторы, которые не открывают файл, должны устанавливать
						fileHandle_ в -1.
					</div>
					<div id="ExplicitCallDestructorCreatedByNew" class="container-content">
						<span class="content-subheader">А могу ли я явно вызывать деструктор для объекта, созданного при помощи new?</span>
						Скорее всего, нет.
						<br><br>
						За исключением того случая, когда вы использовали синтаксис размещения для оператора new
						[11.10], вам следует просто удалять объекты при помощи delete, а не вызывать явно деструктор.
						Предположим, что вы создали объект при помощи обычного new:

						<div class="code-container">
							<pre>Fred* p = new Fred();</pre>
						</div>
						В таком случае деструктор Fred::~Fred() будет автомагически вызван, когда вы удаляете объект:

						<div class="code-container">
							<pre>delete p; // Вызывает p->~Fred()</pre>
						</div>
						Вам не следует явно вызывать деструктор, поскольку этим вы не освобождаете память, выделенную
						для объекта Fred. Помните: delete p делает сразу две вещи [16.8]: вызывает деструктор и
						освобождает память.
					</div>
					<div id="PlacementNew" class="container-content">
						<span class="content-subheader">Что такое "синтаксис размещения" new ("placement new") и зачем он нужен?</span>
						Есть много случаев для использования синтаксиса размещения для new. Самое простое - вы можете
						использовать синтаксис размещения для помещения объекта в определенное место в памяти. Для этого
						вы указываете место, передавая указатель на него в оператор new:

						<div class="code-container"><pre>#include &lt;new&gt; // Необходимо для использования синтаксиса размещения
#include "Fred.h" // Определение класса Fred

void someCode()
{
	char memory[sizeof(Fred)]; // #1
	void* place = memory; // #2

	Fred* f = new(place) Fred(); // #3 (смотрите "ОПАСНОСТЬ" ниже)
	// Указатели f и place будут равны

	// ...
}</pre>
						</div>
						В строчке #1 создаётся массив из sizeof(Fred) байт, размер которого достаточен для хранения
						объекта Fred. В строчке #2 создаётся указатель place, который указывает на первый байт массива
						(опытные программисты на С наверняка заметят, что можно было и не создавать этот указатель; мы
						это сделали лишь чтобы код был более понятным [As if - :) YM]). В строчке #3 фактически
						происходит только вызов конструктора Fred::Fred(). Указатель this в конструкторе Fred будет
						равен указателю place. Таким образом, возвращаемый указатель тоже будет равен place.
						<br><br>
						СОВЕТ: Не используйте синтаксис размещения new, за исключением тех случаев, когда вам
						действительно нужно, чтобы объект был размещён в определённом месте в памяти. Например, если у
						вас есть аппаратный таймер, отображённый на определённый участок памяти, то вам может
						понадобиться поместить объект Clock по этому адресу.
						<br><br>
						ОПАСНО: Используя синтаксис размещения new вы берёте на себя всю ответственность за то, что
						передаваемый вами указатель указывает на достаточный для хранения объекта участок памяти с тем
						выравниванием (alignment), которое необходимо для вашего объекта. Ни компилятор, ни библиотека
						не будут проверять корректность ваших действий в этом случае. Если ваш класс Fred должен быть
						выровнен четырёхбайтовой границе, но вы передали в new указатель на не выровненный участок
						памяти, у вас могут быть большие неприятности (если вы не знаете, что такое "выравнивание"
						(alignment), пожалуйста, не используйте синтаксис размещения new). Мы вас предупредили.
						<br><br>
						Также на вас ложится вся ответственность по уничтожения размещённого объекта. Для этого вам
						необходимо явно вызвать деструктор:


						<div class="code-container"><pre>void someCode()
{
	char memory[sizeof(Fred)];
	void* p = memory;
	Fred* f = new(p) Fred();
	// ...
	f->~Fred(); // Явный вызов деструктора для размещённого объекта
}</pre>
						</div>
						Это практически единственный случай, когда вам нужно явно вызывать деструктор.
					</div>
					<div id="ExplicitObjDestructor" class="container-content">
						<span class="content-subheader">Когда я пишу деструктор, должен ли я явно вызывать деструкторы для объектов-членов моего класса?</span>
						Нет. Никогда не надо явно вызывать деструктор (за исключением случая с синтаксисом размещения
						new [11.10]).
						<br><br>
						Деструктор класса (неявный, созданный компилятором, или явно описанный вами) автоматически
						вызывает деструкторы объектов-членов класса. Эти объекты уничтожаются в порядке обратном порядку
						их объявления в теле класса:

						<div class="code-container"><pre>class Member {
public:
	~Member();
	// ...
};

class Fred {
public:
	~Fred();
	// ...
private:
	Member x_;
	Member y_;
	Member z_;
};

Fred::~Fred()
{
	// Компилятор автоматически вызывает z_.~Member()
	// Компилятор автоматически вызывает y_.~Member()
	// Компилятор автоматически вызывает x_.~Member()
}</pre>
						</div>
					</div>
					<div id="ExplicitCallChildDestructor" class="container-content">
						<span class="content-subheader">Когда я пишу деструктор производного класса, нужно ли мне явно вызывать деструктор предка?</span>
						Нет. Никогда не надо явно вызывать деструктор (за исключением случая с синтаксисом размещения
						new [11.10]).
						<br><br>
						Деструктор производного класса (неявный, созданный компилятором, или явно описанный вами)
						автоматически вызывает деструкторы предков. Предки уничтожаются после уничтожения
						объектов-членов производного класса. В случае множественного наследования непосредственные
						предки класса уничтожаются в порядке обратном порядку их появления в списке наследования.


						<div class="code-container"><pre>class Member {
public:
~Member();
	// ...
};

class Base {
public:
	virtual ~Base(); // Виртуальный деструктор[20.4]
	// ...
};

class Derived : public Base {
public:
	~Derived();
	// ...
private:
	Member x_;
};

Derived::~Derived()
{
	// Компилятор автоматически вызывает x_.~Member()
	// Компилятор автоматически вызывает Base::~Base()
}</pre>
						</div>
						Примечание: в случае виртуального наследования порядок уничтожения классов сложнее. Если вы
						полагаетесь на порядок уничтожения классов в случае виртуального наследования, вам понадобится
						больше информации, чем содержит этот FAQ.
						<br><br>
					</div>
				</div>
			</div>
		</div>
		<!--MAIN ARTICLES END-->

		<!--		SIDEBAR START-->
		<div class="Layout-sidebar bordered-container">
			<div class="container-sidebar">
				<span class="content-header">Содержание</span>
				<details>
					<summary>Ссылки</summary>
					<a class="sidebar-item sidebar-subitem" href="#WhatReference-article">Что такое ссылка?</a>
					<a class="sidebar-item sidebar-subitem" href="#AssignRef-article">Что происходит в результате
					                                                                  присваивания ссылке?</a>
					<a class="sidebar-item sidebar-subitem" href="#ReturnRef-article">Что происходит, когда я возвращаю
					                                                                  из
					                                                                  функции
					                                                                  ссылку?</a>
					<a class="sidebar-item sidebar-subitem" href="#ResetRef-article">Как можно переустановить ссылку,
					                                                                 чтобы
					                                                                 она ссылалась на
					                                                                 другой
					                                                                 объект?</a>
					<a class="sidebar-item sidebar-subitem" href="#RefOrPointer-article">В каких случаях мне стоит
					                                                                     использовать ссылки, и в
					                                                                     каких -
					                                                                     указатели?</a>
				</details>
				<details><summary>Встроенные (inline) функции</summary>
					<a class="sidebar-item sidebar-subitem" href="#WhatInline">Что такое встроенная функция?</a>
					<a class="sidebar-item sidebar-subitem" href="#InlineSafety">Как встроенные функции могут влиять на
					                                                             соотношение безопасности и
					                                                             скорости?</a>
					<a class="sidebar-item sidebar-subitem" href="#WhyInline">Зачем мне использовать встроенные функции?
					                                                          Почему не использовать
					                                                          просто #define макросы?</a>
					<a class="sidebar-item sidebar-subitem" href="#HowDefineInline">Что сделать, чтобы определить
					                                                                функцию -
					                                                                не член класса как
					                                                                встроенную?</a>
					<a class="sidebar-item sidebar-subitem" href="#HowToInlineClassMem">Как сделать встроенной функцию -
					                                                                    член класса?</a>
					<a class="sidebar-item sidebar-subitem" href="#AnotherWayDefineClassMem">Есть ли другой способ
					                                                                         определить встроенную
					                                                                         функцию -
					                                                                         член класса?</a>
					<a class="sidebar-item sidebar-subitem" href="#IsInlineSpeedUp">Обязательно ли встроенные функции
					                                                                приведут к увеличению
					                                                                производительности?</a>
				</details>
				<details>
					<summary>Конструкторы</summary>
					<a class="sidebar-item sidebar-subitem" href="#WhatCtor">Что такое конструкторы?</a>
					<a class="sidebar-item sidebar-subitem" href="#CtorOrInstanceDiff">Есть ли разница между
					                                                                   объявлениями
					                                                                   List x; и List x();?</a>
					<a class="sidebar-item sidebar-subitem" href="#CallOtherCtor">Как из одного конструктора вызвать
					                                                              другой
					                                                              конструктор для инициализации
					                                                              этого объекта?</a>
					<a class="sidebar-item sidebar-subitem" href="#AppearanceCtor">Всегда ли конструктор по умолчанию
					                                                               для
					                                                               Fred выглядит как
					                                                               Fred::Fred()?</a>
					<a class="sidebar-item sidebar-subitem" href="#CtorInArrays">Какой конструктор будет вызван, если я
					                                                             создаю массив объектов типа
					                                                             Fred?</a>
					<a class="sidebar-item sidebar-subitem" href="#CtorInitList">Должны ли мои конструкторы использовать
					                                                             "списки инициализации" или
					                                                             "присваивания значений"?</a>
					<a class="sidebar-item sidebar-subitem" href="#ThisInCtor">Можно ли пользоваться указателем this в
					                                                           конструкторе?</a>
					<a class="sidebar-item sidebar-subitem" href="#NamedCtor">Что такое "именованный конструктор"
					                                                          ("Named
					                                                          Constructor Idiom")?</a>
					<a class="sidebar-item sidebar-subitem" href="#StaticCtorInit">Почему я не могу проинициализировать
					                                                               статический член класса в списке
					                                                               инициализации конструктора?</a>
					<a class="sidebar-item sidebar-subitem" href="#UndefinedExternal">Почему классы со статическими
					                                                                  данными
					                                                                  получают ошибки при
					                                                                  компоновке?</a>
					<a class="sidebar-item sidebar-subitem" href="#StaticInitOrder">Что такое ошибка в порядке
					                                                                статической
					                                                                инициализации ("static
					                                                                initialization order fiasco")?</a>
					<a class="sidebar-item sidebar-subitem" href="#AvoidInitOrderErr">Как предотвратить ошибку в порядке
					                                                                  статической инициализации?</a>
					<a class="sidebar-item sidebar-subitem" href="#AssertStaticInit">Как бороться с ошибками порядка
					                                                                 статической инициализации объектов
					                                                                 -
					                                                                 членов класса?</a>
					<a class="sidebar-item sidebar-subitem" href="#HandleCtorError">Как мне обработать ошибку, которая
					                                                                произошла в конструкторе?</a>
				</details>
				<details><summary>Деструкторы</summary>
					<a class="sidebar-item sidebar-subitem" href="#WhatDestructor">Что такое деструктор?</a>
					<a class="sidebar-item sidebar-subitem" href="#DestructorOrderObj">В каком порядке вызываются
					                                                                   деструкторы для локальных
					                                                                   объектов?</a>
					<a class="sidebar-item sidebar-subitem" href="#DestructorOrderArr">В каком порядке вызываются
					                                                                   деструкторы для массивов
					                                                                   объектов?</a>
					<a class="sidebar-item sidebar-subitem" href="#OverloadDestructor">Могу ли я перегрузить деструктор
					                                                                   для
					                                                                   своего класса?</a>
					<a class="sidebar-item sidebar-subitem" href="#ExplicitCallDestructor">Могу ли я явно вызвать
					                                                                       деструктор
					                                                                       для локальной переменной?</a>
					<a class="sidebar-item sidebar-subitem" href="#ExplicitCallDestructorVar">А что если я хочу, чтобы
					                                                                          локальная переменная
					                                                                          "умерла"
					                                                                          раньше
					                                                                          закрывающей фигурной
					                                                                          скобки?
					                                                                          Могу ли я при крайней
					                                                                          необходимости
					                                                                          вызвать деструктор для
					                                                                          локальной переменной?</a>
					<a class="sidebar-item sidebar-subitem" href="#ExplicitCallDestructorVarSol">Хорошо, я не буду явно
					                                                                             вызывать деструктор. Но
					                                                                             как
					                                                                             мне справиться с
					                                                                             этой проблемой?</a>
					<a class="sidebar-item sidebar-subitem" href="#ExplicitCallDestructorVarOtherSol">А что делать, если
					                                                                                  я
					                                                                                  не могу поместить
					                                                                                  переменную в
					                                                                                  отдельный
					                                                                                  блок?</a>
					<a class="sidebar-item sidebar-subitem" href="#ExplicitCallDestructorCreatedByNew">А могу ли я явно
					                                                                                   вызывать
					                                                                                   деструктор
					                                                                                   для объекта,
					                                                                                   созданного при
					                                                                                   помощи
					                                                                                   new?</a>
					<a class="sidebar-item sidebar-subitem" href="#PlacementNew">Что такое "синтаксис размещения" new
					                                                             ("placement new") и зачем он
					                                                             нужен?</a>
					<a class="sidebar-item sidebar-subitem" href="#ExplicitObjDestructor">Когда я пишу деструктор,
					                                                                      должен ли
					                                                                      я явно вызывать деструкторы
					                                                                      для
					                                                                      объектов-членов моего
					                                                                      класса?</a>
					<a class="sidebar-item sidebar-subitem" href="#ExplicitCallChildDestructor">Когда я пишу деструктор
					                                                                            производного класса,
					                                                                            нужно
					                                                                            ли мне явно вызывать
					                                                                            деструктор
					                                                                            предка?</a></details>
			</div>
		</div>
		<!--		SIDEBAR END-->
	</div>

</main>
<!--FOOTER START-->
<footer class="footer centered-container border-top">
	<div class="flex-container flex-items-center f12">
		<ul class="list-style-none" style="margin-top: 6px;width: 16%;">
			<li class="flex-items-center">
				<a class="header-link" href="https://github.com/Antoher0101" target="_blank">
					<span>
						<img alt="@Antoher0101" class="avatar circle"
						     height="24" src="https://avatars.githubusercontent.com/u/62786345?s=96&amp;v=4" width="24">
					 © 2022 Antoher0101 </span>
				</a>
			</li>
		</ul>
		<ul class="flex-ul list-style-none two-third-width flex-space-between">
			<li class="flex-items-center"><a href="https://github.com/Antoher0101/wwwLearnCpp" target="_self">This
			                                                                                                  repository</a>
			</li>
			<li class="flex-items-center"><a href="https://github.com/Antoher0101/wwwLearnCpp/commits/master"
			                                 target="_blank">Commits</a></li>
			<li class="flex-items-center"><a href="https://github.com/Antoher0101/wwwLearnCpp/blob/master/README.md"
			                                 target="_blank">About</a></li>
		</ul>
	</div>
</footer>
<!--FOOTER END-->
</body>
</html>